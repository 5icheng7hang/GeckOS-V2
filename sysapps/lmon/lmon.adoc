
= LMON(1)
:doctype: manpage

== NAME
lmon - machine language monitor

== SYNOPSIS
*lmon*

== DESCRIPTION
Machine language monitor, derived from the C64 @MON monitor.

When started, the monitor prints the CPU registers, and waits for
the commands at the prompt.

== COMMANDS
*R*::
	print the internal copy of the CPU registers

*G* <addr>::
	Start executing code at <addr>. Set CPU registers with the
	values of the internal Registers
	Returns to monitor on RTS.

*X*::
	exit the monitor

=== ASSEMBLER
*D* <start> [<end>]::
	print disassembly from <start> to <end> address

*A* <start>::
	Start assembling at given start address

*U* <startfrom> <endfrom> <starttarget> <endtarget> <newtarget>::
	In the area between <startfrom> and <endfrom>, re-calculate
	all 3-byte addresses in machine code that point to between
	<starttarget> and <endtarget> to a new area starting at
	<newtarget>

*FR* <start> <end>::
	Search for relative jump opcodes in given area

*FA* <adr1> <adr2> xxx::
	search for a special addressing mode:
        you give the adressing mode in the same syntax
        as in the assembler, instead of the real address
        you may replace some or all of the Hex digits 
        by an asterix ('*').
        example: FA A437 A500 $A32*,X


=== NUMBERS
#decimal_number::
	prints the hex, decimal and binary values of
	the given decimal number

$hex_number::
	prints the hex, decimal and binary values of
	the given hex number

%bin_number::
	prints the hex, decimal and binary values of
	the given binary number

? adr1 operator adr2::
	performs arithmetik operation, valid operators are:
        +   addition
        -   substraction
        *   multiplication
        /   division

=== SYSTEM
*S* "filename" <start> <end>::
	save a memory are to a file

*L* "filename" <start>::
	load a file into memory area starting at <start>.

*P* <drive> [<memsize>]::
	Set the default drive for file operations, and the 
	maximum available memory (in MMU systems).
	If drive is "-" then the drive is not changed.

*I* <byte1> <byte2>::
	Sets output to Disk to device byte1 and
	output to printer to device byte2

*E* <page> <block>::
	In MMU systems, set page <page> to memory mapped block <block>.

=== COMPLEX 
*C* <startsrc> <endsrc> <starttrg>::
	show differences between the area <startsrc> - <endsrc> 
	and the area starting at <starttrg>.

*F* <start> <end> <byte1> [<byte2> ...]::
*F* <start> <end> "text"::
	Search for <search> in the memory area between <start> and <end>.
	<search> can be either hex numbers, quoted strings, or both mixed.

*T* <start> <end> <trg>::
	Transfer memory area from <start> to <end> to the memory
	area at <trg>

*O* <start> <end> <value>::
	Fill (Occupy) memory area from <start> to <end> with <value>

== EXAMPLES


== AUTHOR
Written by André Fachat

== REPORTING BUGS
Please report bugs at https://github.com/fachat/GeckOS-V2/issues

== COPYRIGHT
Copyright 1997, 2020 André Fachat. License GPL2 or later.
This is free software: you are free to change and redistribute it. There is no WARRANTY, to the extent permitted by law.

== SEE ALSO



